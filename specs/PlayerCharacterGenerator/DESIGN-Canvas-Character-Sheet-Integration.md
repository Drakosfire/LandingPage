# Canvas-Integrated Character Sheet Design

**Date:** December 5, 2025 (Updated)  
**Status:** DESIGN - LOCKED âœ…  
**Purpose:** Comprehensive design for building PHB-style character sheets with static layouts and overflow pagination

---

## 1. Executive Summary

This document synthesizes research from:
- **RESEARCH-HTML-CharacterSheet-Implementations.md** - 4 open-source HTML character sheets
- **PHB-Style Multi-Page D&D 5e Character Sheets** - Homebrewery CSS patterns
- **ANALYSIS-Page-Layout-Components.md** - Static vs Dynamic component classification
- **HTML Prototypes** - `character-sheet.html`, `spell-sheet.html`, `inventory-sheet.html`

### Design Decision: Static Pages + Overflow

**We are NOT using Canvas's full measurement-based pagination for main pages.**

Instead, we use a **hybrid approach**:
- **Main pages**: Static layout (no measurement needed) with bounded sections
- **Overflow pages**: Simple list continuations, optionally Canvas-paginated if very long

### Goal
Build a PHB-styled, multi-page character sheet with:
- **Static main page layouts** (predictable, printable)
- **Bounded sections** with slice-based overflow detection
- **Overflow pages** for content that exceeds bounds
- **PHB theme styling** matching official D&D look
- **Component registry** for consistent rendering

---

## 2. Architecture Overview

### 2.1 Key Difference from StatblockGenerator

| Aspect | StatblockGenerator | CharacterSheets |
|--------|-------------------|-----------------|
| **Layout** | Single template, Canvas-paginated | Multiple static page templates |
| **Measurement** | All components measured | Only bounded sections need limits |
| **Overflow** | Canvas column/page flow | Simple slice-based to overflow pages |
| **Columns** | 2 columns within single page | 3 columns within static layout |
| **Pages** | Dynamically generated by Canvas | Fixed sequence: Character â†’ Spells â†’ Inventory |

### 2.2 Target Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CharacterSheetDocument (Entry Point)                             â”‚
â”‚ - Orchestrates page sequence                                     â”‚
â”‚ - Handles overflow detection                                     â”‚
â”‚ - Renders pages as array                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Page Components (Static Layout)                                  â”‚
â”‚                                                                  â”‚
â”‚  CharacterMainPage     SpellMainPage       InventoryMainPage    â”‚
â”‚  - Static 3-column     - Static 3-column   - Static 3-column    â”‚
â”‚  - Bounded sections    - Bounded sections  - Bounded sections   â”‚
â”‚  - Slice to LIMITS     - Slice to LIMITS   - Slice to LIMITS    â”‚
â”‚                                                                  â”‚
â”‚  CharacterOverflow     SpellOverflow       InventoryOverflow    â”‚
â”‚  - Continuation lists  - Continuation lists - Continuation lists â”‚
â”‚  - Optional Canvas     - Optional Canvas    - Optional Canvas    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Section Components (Reusable)                                    â”‚
â”‚                                                                  â”‚
â”‚  Static Sections:            Bounded Sections:                   â”‚
â”‚  - HeaderSection             - FeaturesSection (max N items)     â”‚
â”‚  - AbilityScoresRow          - AttacksSection (max N items)      â”‚
â”‚  - SavingThrows              - EquipmentSection (max N items)    â”‚
â”‚  - SkillsBlock               - SpellLevelBlock (max N spells)    â”‚
â”‚  - CombatStats               - NotesSection (max height)         â”‚
â”‚  - DeathSaves                                                    â”‚
â”‚  - etc...                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Page Flow

```
Character Main (Page 1)
  â””â”€â”€ hasOverflow? â†’ Character Overflow (Page 1.1)
        â†“
Spell Main (Page 2) [if isSpellcaster]
  â””â”€â”€ hasOverflow? â†’ Spell Overflow (Page 2.1)
        â†“
Inventory Main (Page 3)
  â””â”€â”€ hasOverflow? â†’ Inventory Overflow (Page 3.1)
```

---

## 3. Component Architecture

### 3.1 Component Classification

Based on `ANALYSIS-Page-Layout-Components.md`, components are classified as:

| Type | Behavior | Examples | Canvas Needed? |
|------|----------|----------|----------------|
| **ğŸ”’ STATIC** | Fixed size, never grows | Ability Scores, Saves, Skills, HP | NO |
| **ğŸ“ˆ BOUNDED** | Has MAX items on main page | Features, Attacks, Equipment | NO (slice-based) |
| **ğŸ”„ OVERFLOW** | Continuation from main page | Features (cont.), Spells (cont.) | OPTIONAL |

### 3.2 Character Sheet Components (from prototype)

```
CHARACTER MAIN PAGE (character-sheet.html)
â”œâ”€â”€ Header Section (STATIC)
â”‚   â”œâ”€â”€ Portrait                    â†’ CharacterPortrait
â”‚   â”œâ”€â”€ Character Name              â†’ HeaderInfoBox
â”‚   â”œâ”€â”€ Class & Level               â†’ HeaderInfoBox
â”‚   â”œâ”€â”€ Background                  â†’ HeaderInfoBox
â”‚   â”œâ”€â”€ Player Name                 â†’ HeaderInfoBox
â”‚   â”œâ”€â”€ Race                        â†’ HeaderInfoBox
â”‚   â”œâ”€â”€ Alignment                   â†’ HeaderInfoBox
â”‚   â””â”€â”€ Experience Points           â†’ HeaderInfoBox
â”‚
â”œâ”€â”€ Ability Scores Row (STATIC)
â”‚   â””â”€â”€ 6 Ã— AbilityBox (STR, DEX, CON, INT, WIS, CHA)
â”‚
â”œâ”€â”€ Column 1 (mostly STATIC)
â”‚   â”œâ”€â”€ Inspiration/Prof Bonus      â†’ TopStatsBox
â”‚   â”œâ”€â”€ Saving Throws (6 rows)      â†’ SavingThrowsSection
â”‚   â”œâ”€â”€ Skills (18 rows)            â†’ SkillsSection
â”‚   â”œâ”€â”€ Passive Perception          â†’ PassivePerceptionBox
â”‚   â””â”€â”€ Proficiencies (BOUNDED)     â†’ ProficienciesSection
â”‚
â”œâ”€â”€ Column 2 (mix of STATIC + BOUNDED)
â”‚   â”œâ”€â”€ AC/Init/Speed               â†’ CombatStatsRow
â”‚   â”œâ”€â”€ HP Section                  â†’ HPSection
â”‚   â”œâ”€â”€ Hit Dice                    â†’ HitDiceSection
â”‚   â”œâ”€â”€ Death Saves                 â†’ DeathSavesSection
â”‚   â”œâ”€â”€ Attacks (BOUNDED, max 5)    â†’ AttacksSection
â”‚   â””â”€â”€ Equipment (BOUNDED, max 12) â†’ EquipmentSection
â”‚
â””â”€â”€ Column 3 (mix of STATIC + BOUNDED)
    â”œâ”€â”€ Personality                 â†’ PersonalityBox
    â”œâ”€â”€ Ideals                      â†’ PersonalityBox
    â”œâ”€â”€ Bonds                       â†’ PersonalityBox
    â”œâ”€â”€ Flaws                       â†’ PersonalityBox
    â”œâ”€â”€ Features (BOUNDED, max 8)   â†’ FeaturesSection
    â””â”€â”€ Notes (BOUNDED)             â†’ NotesSection
```

### 3.3 Spell Sheet Components (from prototype)

```
SPELL MAIN PAGE (spell-sheet.html)
â”œâ”€â”€ Page Title                      â†’ PageTitle ("Spellcasting")
â”œâ”€â”€ Header Section (STATIC)
â”‚   â”œâ”€â”€ Spellcasting Class          â†’ SpellStatBox
â”‚   â”œâ”€â”€ Spell Ability               â†’ SpellStatBox
â”‚   â”œâ”€â”€ Spell Save DC               â†’ SpellStatBox
â”‚   â””â”€â”€ Spell Attack Bonus          â†’ SpellStatBox
â”‚
â”œâ”€â”€ Spell Slots Row (STATIC)
â”‚   â””â”€â”€ 9 Ã— SpellSlotLevel (1st-9th)
â”‚
â””â”€â”€ Spell List Container (BOUNDED per level)
    â”œâ”€â”€ Cantrips (max 8)            â†’ SpellLevelBlock
    â”œâ”€â”€ 1st Level (max 8)           â†’ SpellLevelBlock
    â”œâ”€â”€ 2nd Level (max 8)           â†’ SpellLevelBlock
    â”œâ”€â”€ ... through 9th Level
    â””â”€â”€ Each level: BOUNDED         â†’ SpellLevelBlock
```

### 3.4 Inventory Sheet Components (from prototype)

```
INVENTORY MAIN PAGE (inventory-sheet.html)
â”œâ”€â”€ Page Title                      â†’ PageTitle ("Inventory")
â”œâ”€â”€ Header Section (STATIC)
â”‚   â”œâ”€â”€ Character Name              â†’ InventoryHeaderInfo
â”‚   â”œâ”€â”€ Class & Level               â†’ InventoryHeaderInfo
â”‚   â””â”€â”€ Strength                    â†’ InventoryHeaderInfo
â”‚
â”œâ”€â”€ Top Row (STATIC)
â”‚   â”œâ”€â”€ Currency (5 coins)          â†’ CurrencySection
â”‚   â”œâ”€â”€ Encumbrance                 â†’ EncumbranceSection
â”‚   â””â”€â”€ Attunement (3 slots)        â†’ AttunementSection
â”‚
â””â”€â”€ Main Content (BOUNDED)
    â”œâ”€â”€ Weapons (max 6)             â†’ InventoryBlock
    â”œâ”€â”€ Armor & Shields (max 4)     â†’ InventoryBlock
    â”œâ”€â”€ Magic Items (max 8)         â†’ InventoryBlock
    â”œâ”€â”€ Adventuring Gear (max 15)   â†’ InventoryBlock
    â”œâ”€â”€ Containers (max 3)          â†’ ContainerBlock
    â””â”€â”€ Notes (BOUNDED)             â†’ NotesSection
```

### 3.5 Section Limits (Constants)

```typescript
// src/components/PlayerCharacterGenerator/constants/sectionLimits.ts

export const CHARACTER_SECTION_LIMITS = {
    // Character Sheet Main Page
    attacks: 5,           // ~120px available
    equipment: 12,        // ~180px available
    features: 8,          // ~200px available
    proficiencies: 6,     // ~80px available
    notes: 150,           // characters (height limited)
    
    // Spell Sheet Main Page
    spellsPerLevel: 8,    // per spell level section
    
    // Inventory Sheet Main Page
    weapons: 6,
    armor: 4,
    magicItems: 8,
    adventuringGear: 15,
    containers: 3,
    inventoryNotes: 150,  // characters
} as const;

---

## 4. Page Templates (Not Canvas Templates)

**Key Decision:** Since we're using static layouts, we don't need Canvas `TemplateConfig` with measurement-based regions. Instead, we define **Page Components** that render fixed layouts.

### 4.1 Page Template Structure

Each page template is a **React component** that renders a fixed layout:

```typescript
// src/components/PlayerCharacterGenerator/pages/CharacterMainPage.tsx

interface CharacterMainPageProps {
    character: Character;
    limits: typeof CHARACTER_SECTION_LIMITS;
    onUpdateData?: (updates: Partial<Character>) => void;
    isEditMode?: boolean;
}

export const CharacterMainPage: React.FC<CharacterMainPageProps> = ({
    character,
    limits,
    onUpdateData,
    isEditMode,
}) => {
    // Slice data to fit on main page
    const featuresMain = character.features.slice(0, limits.features);
    const attacksMain = character.attacks.slice(0, limits.attacks);
    const equipmentMain = character.equipment.slice(0, limits.equipment);
    
    // Track what overflows
    const hasMore = {
        features: character.features.length > limits.features,
        attacks: character.attacks.length > limits.attacks,
        equipment: character.equipment.length > limits.equipment,
    };
    
    return (
        <div className="phb-page character-sheet">
            <HeaderSection character={character} />
            <AbilityScoresRow abilities={character.abilities} />
            
            <div className="main-content">
                <div className="column-1">
                    <TopStatsBox 
                        inspiration={character.inspiration}
                        proficiencyBonus={character.proficiencyBonus}
                    />
                    <SavingThrowsSection saves={character.savingThrows} />
                    <SkillsSection skills={character.skills} />
                    <PassivePerceptionBox value={character.passivePerception} />
                    <ProficienciesSection proficiencies={character.proficiencies} />
                </div>
                
                <div className="column-2">
                    <CombatStatsRow stats={character.combatStats} />
                    <HPSection hp={character.hp} />
                    <HitDiceSection hitDice={character.hitDice} />
                    <DeathSavesSection />
                    <AttacksSection 
                        attacks={attacksMain}
                        hasMore={hasMore.attacks}
                    />
                    <EquipmentSection
                        equipment={equipmentMain}
                        currency={character.currency}
                        hasMore={hasMore.equipment}
                    />
                </div>
                
                <div className="column-3">
                    <PersonalityBox label="Personality" value={character.personality} />
                    <PersonalityBox label="Ideals" value={character.ideals} />
                    <PersonalityBox label="Bonds" value={character.bonds} />
                    <PersonalityBox label="Flaws" value={character.flaws} />
                    <FeaturesSection
                        features={featuresMain}
                        hasMore={hasMore.features}
                    />
                    <NotesSection notes={character.notes} />
                </div>
            </div>
            
            <hr className="phb-separator" />
        </div>
    );
};
```

### 4.2 Overflow Page Template

```typescript
// src/components/PlayerCharacterGenerator/pages/CharacterOverflowPage.tsx

interface CharacterOverflowPageProps {
    features: Feature[];
    attacks: Attack[];
    equipment: EquipmentItem[];
}

export const CharacterOverflowPage: React.FC<CharacterOverflowPageProps> = ({
    features,
    attacks,
    equipment,
}) => {
    // If nothing to show, don't render the page
    if (features.length === 0 && attacks.length === 0 && equipment.length === 0) {
        return null;
    }
    
    return (
        <div className="phb-page character-overflow">
            <div className="phb-page-title">Character Details (continued)</div>
            
            <div className="overflow-content">
                {features.length > 0 && (
                    <FeaturesSection
                        features={features}
                        title="Features & Traits (cont.)"
                        isContinuation
                    />
                )}
                
                {attacks.length > 0 && (
                    <AttacksSection
                        attacks={attacks}
                        title="Attacks (cont.)"
                        isContinuation
                    />
                )}
                
                {equipment.length > 0 && (
                    <EquipmentSection
                        equipment={equipment}
                        title="Equipment (cont.)"
                        isContinuation
                    />
                )}
            </div>
            
            <hr className="phb-separator" />
        </div>
    );
};
```

### 4.3 Document Orchestrator

The top-level component assembles all pages:

```typescript
// src/components/PlayerCharacterGenerator/CharacterSheetDocument.tsx

interface CharacterSheetDocumentProps {
    character: Character;
    isEditMode?: boolean;
    onUpdateData?: (updates: Partial<Character>) => void;
}

export const CharacterSheetDocument: React.FC<CharacterSheetDocumentProps> = ({
    character,
    isEditMode,
    onUpdateData,
}) => {
    const limits = CHARACTER_SECTION_LIMITS;
    
    // Calculate overflow data
    const overflow = {
        features: character.features.slice(limits.features),
        attacks: character.attacks.slice(limits.attacks),
        equipment: character.equipment.slice(limits.equipment),
        // ... more sections
    };
    
    const hasCharacterOverflow = 
        overflow.features.length > 0 ||
        overflow.attacks.length > 0 ||
        overflow.equipment.length > 0;
    
    const isSpellcaster = character.spellcasting != null;
    
    return (
        <div className="character-sheet-document">
            {/* Page 1: Character Main */}
            <CharacterMainPage
                character={character}
                limits={limits}
                isEditMode={isEditMode}
                onUpdateData={onUpdateData}
            />
            
            {/* Page 1.1: Character Overflow (if needed) */}
            {hasCharacterOverflow && (
                <CharacterOverflowPage
                    features={overflow.features}
                    attacks={overflow.attacks}
                    equipment={overflow.equipment}
                />
            )}
            
            {/* Page 2: Spells Main (if spellcaster) */}
            {isSpellcaster && (
                <SpellMainPage
                    spellcasting={character.spellcasting}
                    limits={limits}
                />
            )}
            
            {/* Page 2.1: Spell Overflow (if needed) */}
            {/* ... */}
            
            {/* Page 3: Inventory Main */}
            <InventoryMainPage
                inventory={character.inventory}
                currency={character.currency}
                limits={limits}
            />
            
            {/* Page 3.1: Inventory Overflow (if needed) */}
            {/* ... */}
        </div>
    );
};
```

---

## 5. Canvas Strengths vs PCG Needs Analysis

### 5.1 Canvas Package Strengths

The `@dungeonmind/canvas` package excels at:

| Strength | Description | Relevance to PCG |
|----------|-------------|------------------|
| **Measurement-Based Pagination** | Measures actual rendered heights, splits content across columns/pages | âš ï¸ Only for overflow pages |
| **Responsive Scaling** | Auto-calculates scale based on container width | âœ… Useful for print preview |
| **Font Loading Coordination** | Waits for fonts before measuring | âœ… Critical for PHB fonts |
| **Layout Plan Generation** | Creates deterministic page/column/entry structure | âš ï¸ Only for overflow pages |
| **Component Registry** | Type-safe component lookup and defaults | âœ… Can reuse pattern |
| **Adapter Pattern** | Domain-specific logic separated from engine | âœ… Need character adapters |
| **CSS Variable System** | `--dm-page-*` variables for theming | âœ… Can adopt same pattern |

### 5.2 PCG's Unique Characteristics

| PCG Characteristic | Why It's Different from Statblocks |
|--------------------|-----------------------------------|
| **3-column layout** | Statblocks use 2 columns; PHB character sheets use 3 |
| **Fixed page structure** | Sections have fixed positions, not flow-based |
| **56% static components** | Most components never change size |
| **Bounded sections** | Features/Equipment have max items, not unlimited |
| **Multiple page types** | 3 distinct page designs (Character, Spell, Inventory) |
| **Overflow is exception** | Main pages should fit most characters |

### 5.3 StatblockGenerator â†’ Canvas Contract

```typescript
// StatblockGenerator provides to Canvas:
interface StatblockCanvasContract {
    // Data
    page: StatblockPageDocument;          // Complete page state
    dataSources: ComponentDataSource[];    // [{ type: 'statblock', payload: StatBlockDetails }]
    
    // Configuration
    template: TemplateConfig;              // Slots, defaultComponents, pageVariables
    componentRegistry: Record<string, ComponentRegistryEntry>;
    adapters: CanvasAdapters;              // statblockDataResolver, statblockHeightEstimator, etc.
    
    // Canvas config (Phase 5)
    config: CanvasConfig;                  // pageVariables, frameConfig, ready
}

// Canvas provides to StatblockGenerator:
interface CanvasToStatblockContract {
    plan: LayoutPlan;                      // Pages with columns and entries
    measurementEntries: MeasurementEntry[]; // What to measure
    onMeasurements: (updates) => void;     // Receive measurements
    dimensions: CanvasDimensions;          // Calculated widths, heights
    baseDimensions: BasePageDimensions;    // Page metrics
    MeasurementLayer: Component;           // Offscreen measurement
    // ... more
}

// StatblockGenerator uses:
// 1. CanvasLayoutProvider (wraps component tree)
// 2. useCanvasLayout() hook (receives layout plan)
// 3. CanvasPage (renders layout plan)
// 4. MeasurementPortal (offscreen measurement)
```

**Key Insight:** StatblockGenerator delegates ALL layout decisions to Canvas. Content flows dynamically based on measurements.

### 5.4 PlayerCharacterGenerator â†’ Canvas Contract

```typescript
// PCG MINIMAL Canvas usage:
interface PCGCanvasContract {
    // PCG does NOT use for main pages:
    âŒ CanvasLayoutProvider
    âŒ useCanvasLayout()
    âŒ CanvasPage
    âŒ MeasurementLayer
    âŒ Full TemplateConfig with slots/regions
    
    // PCG MAY use for overflow pages:
    âš ï¸ Simple Canvas pagination (if overflow > 1 page)
    
    // PCG DOES use:
    âœ… PHB font loading pattern (usePHBTheme)
    âœ… Responsive scaling pattern (ResizeObserver)
    âœ… CSS variable system (--dm-page-*, --dm-column-*)
    âœ… Component registry pattern (for consistency)
    âœ… Adapter pattern (characterDataResolver, etc.)
}

// PCG owns:
interface PCGOwnsContract {
    // Page orchestration
    renderPages: () => ReactNode[];         // Decide which pages to render
    calculateOverflow: () => OverflowData;  // Slice data for bounded sections
    
    // Static layouts
    CharacterMainPage: Component;           // Fixed 3-column layout
    SpellMainPage: Component;               // Fixed spell list layout
    InventoryMainPage: Component;           // Fixed inventory layout
    
    // Overflow pages (simpler than main)
    CharacterOverflowPage: Component;       // List continuations
    SpellOverflowPage: Component;
    InventoryOverflowPage: Component;
}
```

### 5.5 Contract Comparison Matrix

| Aspect | StatblockGenerator | PlayerCharacterGenerator |
|--------|-------------------|-------------------------|
| **Layout ownership** | Canvas owns | PCG owns |
| **Page count** | Dynamically calculated | Fixed (3) + optional overflow |
| **Component placement** | Canvas places via slots | PCG places via JSX |
| **Measurement use** | All components measured | Only for overflow estimation |
| **Data flow** | dataSources â†’ Canvas â†’ components | character â†’ pages â†’ sections |
| **Pagination** | Canvas splits lists automatically | PCG slices to LIMITS, renders overflow |
| **Adapters needed** | Full suite (resolver, estimator, normalizer) | Minimal (maybe heightEstimator for overflow) |

### 5.6 What PCG Adopts from Canvas

```typescript
// 1. Font Loading Pattern (from StatblockPage.tsx)
const { isLoaded: fontsLoaded } = usePHBTheme(DND_CSS_BASE_URL);
await Promise.all([
    document.fonts.load('700 24px NodestoCapsCondensed'),
    document.fonts.load('400 14px ScalySansRemake'),
    document.fonts.load('700 14px ScalySansRemake'),
]);

// 2. Responsive Scaling Pattern (from StatblockPage.tsx)
const PAGE_WIDTH_PX = 816;  // US Letter at 96dpi
const containerRef = useRef<HTMLDivElement>(null);
const [scale, setScale] = useState(1);

useLayoutEffect(() => {
    const observer = new ResizeObserver((entries) => {
        const width = entries[0].contentRect.width;
        setScale(Math.min(1, width / PAGE_WIDTH_PX));
    });
    observer.observe(containerRef.current);
    return () => observer.disconnect();
}, []);

// 3. CSS Variable Pattern
const containerStyle = {
    '--dm-page-width': `${PAGE_WIDTH_PX}px`,
    '--dm-page-height': `${PAGE_HEIGHT_PX}px`,
    '--dm-page-scale': `${scale}`,
};

// 4. Component Registry Pattern (structure, not full Canvas integration)
export const CHARACTER_COMPONENT_REGISTRY: Record<string, ComponentDef> = {
    'character-header': CharacterHeader,
    'ability-scores': AbilityScoresRow,
    // ...
};

// 5. Adapter Pattern (for future Canvas overflow, if needed)
export const createCharacterAdapters = (): Partial<CanvasAdapters> => ({
    dataResolver: characterDataResolver,
    heightEstimator: characterHeightEstimator,
    // ...
});
```

### 5.7 What PCG Does NOT Use from Canvas

```typescript
// âŒ NOT using CanvasLayoutProvider
// (no layout state management needed for static pages)

// âŒ NOT using useCanvasLayout() hook
// (no measurement â†’ pagination cycle)

// âŒ NOT using CanvasPage component
// (rendering fixed layouts, not dynamic plans)

// âŒ NOT using MeasurementLayer/MeasurementPortal
// (no offscreen measurement for main pages)

// âŒ NOT using TemplateConfig with slots/regions
// (slots are for dynamic placement, we use fixed JSX)

// âŒ NOT using buildPageDocument()
// (no page document â†’ component instances conversion)
```

### 5.8 Summary: The PCG-Canvas Contract

**PCG uses Canvas as a LIBRARY OF PATTERNS, not as a LAYOUT ENGINE.**

| From Canvas | PCG Usage |
|-------------|-----------|
| Font loading | Direct copy |
| Responsive scaling | Direct copy |
| CSS variables | Adopt naming |
| Component registry | Pattern only (not full integration) |
| Adapters | Minimal (for potential overflow) |
| Layout engine | NOT USED for main pages |
| Measurement system | NOT USED for main pages |

**The relationship is:**
- **StatblockGenerator**: Canvas is the **orchestrator** (Canvas decides where content goes)
- **PlayerCharacterGenerator**: Canvas is a **toolbox** (PCG decides layout, borrows patterns)

---

## 6. CSS Enhancements

### 5.1 New CSS Patterns from Research

Add these patterns from the HTML character sheet research to `CharacterComponents.css`:

```css
/* ===== From CodePen YVVeMd: Enhanced Ability Score Boxes ===== */
.ability-box-enhanced {
    height: 80px;
    width: 70px;
    background-color: white;
    border: 1px solid black;
    border-radius: 10px;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.ability-box-enhanced .ability-modifier-circle {
    width: 30px;
    height: 20px;
    border: 1px inset black;
    border-radius: 20px;
    text-align: center;
    margin: 0 auto;
    font-size: 0.9rem;
    line-height: 20px;
}

/* ===== From lckynmbrsvn: Expertise Support ===== */
.proficiency-marker.expertise::before {
    content: 'â—';  /* Half-filled for expertise */
}

/* ===== From CodePen: Circular Combat Stats ===== */
.combat-stat-circle {
    height: 70px;
    width: 70px;
    border-radius: 50%;
    border: 2px solid black;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    background: rgba(255, 255, 255, 0.5);
}

.combat-stat-circle .stat-value {
    font-size: 24px;
    font-weight: bold;
}

.combat-stat-circle .stat-label {
    font-size: 8px;
    text-transform: uppercase;
}

/* ===== From lckynmbrsvn: Resource Tracker ===== */
.resource-tracker {
    display: flex;
    align-items: center;
    gap: 0.2cm;
}

.resource-tracker-name {
    font-family: 'ScalySansRemake', sans-serif;
    font-size: 0.85rem;
    min-width: 5em;
}

.resource-tracker-boxes {
    display: flex;
    gap: 0.1cm;
}

.resource-box::before {
    content: 'â–¡';
    font-size: 1rem;
}

.resource-box.used::before {
    content: 'â– ';
}

/* ===== From CodePen: Textblock with Bottom Label ===== */
.textblock-with-label {
    display: flex;
    flex-direction: column-reverse;
    width: 100%;
    align-items: center;
}

.textblock-with-label textarea {
    width: calc(100% - 20px);
    border-radius: 10px 10px 0 0;
    padding: 10px;
    resize: none;
    font-family: 'ScalySansRemake', sans-serif;
    font-size: 0.85rem;
}

.textblock-with-label label {
    border: 1px solid black;
    border-top: 0;
    border-radius: 0 0 10px 10px;
    padding: 4px 0;
    width: calc(100% - 20px);
    text-align: center;
    font-size: 10px;
    font-weight: bold;
    text-transform: uppercase;
}

/* ===== From CodePen: Money Section ===== */
.currency-display {
    display: flex;
    gap: 0.3cm;
}

.currency-item {
    display: flex;
    align-items: center;
}

.currency-item label {
    border: 1px solid black;
    border-radius: 10px 0 0 10px;
    border-right: 0;
    width: 20px;
    font-size: 8px;
    text-align: center;
    padding: 3px 0;
    background: #f4f4f4;
}

.currency-item input {
    border: 1px solid black;
    border-radius: 0 10px 10px 0;
    width: 40px;
    padding: 3px;
    font-size: 12px;
    text-align: center;
}
```

### 5.2 CSS Variables Update

Add to `CharacterComponents.css`:

```css
:root {
    /* Character Sheet Specific Variables */
    --char-ability-box-size: 70px;
    --char-ability-score-font: 1.4rem;
    --char-ability-mod-size: 20px;
    
    --char-combat-stat-size: 60px;
    --char-combat-stat-font: 24px;
    
    --char-prof-marker-size: 10px;
    --char-prof-marker-filled: #000;
    --char-prof-marker-empty: #fff;
    
    --char-frame-bg: #faf2cc;
    --char-frame-border: #000;
    --char-frame-radius: 4px;
}
```

---

## 7. Implementation (Static Pages Approach)

### 7.1 CharacterSheetDocument.tsx (Entry Point)

```typescript
// src/components/PlayerCharacterGenerator/CharacterSheetDocument.tsx

import React, { useRef, useState, useLayoutEffect } from 'react';
import { usePHBTheme } from '../../hooks/useTheme';
import { CHARACTER_SECTION_LIMITS } from './constants/sectionLimits';
import { CharacterMainPage } from './pages/CharacterMainPage';
import { CharacterOverflowPage } from './pages/CharacterOverflowPage';
import { SpellMainPage } from './pages/SpellMainPage';
import { SpellOverflowPage } from './pages/SpellOverflowPage';
import { InventoryMainPage } from './pages/InventoryMainPage';
import { InventoryOverflowPage } from './pages/InventoryOverflowPage';
import './styles/CharacterSheet.css';

// Page dimensions (US Letter at 96dpi)
const PAGE_WIDTH_PX = 816;
const PAGE_HEIGHT_PX = 1056;
const MIN_SCALE = 0.35;
const MAX_SCALE = 1.5;

interface CharacterSheetDocumentProps {
    character: Character;
    isEditMode?: boolean;
    onUpdateData?: (updates: Partial<Character>) => void;
}

export const CharacterSheetDocument: React.FC<CharacterSheetDocumentProps> = ({
    character,
    isEditMode = false,
    onUpdateData,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [scale, setScale] = useState(1);
    const [fontsReady, setFontsReady] = useState(false);
    
    // Load PHB fonts (borrowed from Canvas pattern)
    useLayoutEffect(() => {
        const loadFonts = async () => {
            try {
                await Promise.all([
                    document.fonts.load('700 24px NodestoCapsCondensed'),
                    document.fonts.load('400 14px ScalySansRemake'),
                    document.fonts.load('700 14px ScalySansRemake'),
                    document.fonts.load('400 14px BookInsanityRemake'),
                ]);
                await document.fonts.ready;
                setFontsReady(true);
            } catch (error) {
                console.warn('[CharacterSheet] Font loading failed:', error);
                setFontsReady(true); // Proceed anyway
            }
        };
        loadFonts();
    }, []);
    
    // Responsive scaling (borrowed from Canvas pattern)
    useLayoutEffect(() => {
        if (!containerRef.current) return;
        
        const observer = new ResizeObserver((entries) => {
            const width = entries[0].contentRect.width;
            const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, width / PAGE_WIDTH_PX));
            setScale(newScale);
        });
        
        observer.observe(containerRef.current);
        return () => observer.disconnect();
    }, []);
    
    // Calculate overflow data using simple slicing
    const limits = CHARACTER_SECTION_LIMITS;
    const overflow = {
        features: character.features?.slice(limits.features) ?? [],
        attacks: character.attacks?.slice(limits.attacks) ?? [],
        equipment: character.equipment?.slice(limits.equipment) ?? [],
        // Spell overflow per level
        spells: Object.fromEntries(
            Object.entries(character.spellcasting?.spellsByLevel ?? {}).map(
                ([level, spells]) => [level, spells.slice(limits.spellsPerLevel)]
            )
        ),
        // Inventory overflow
        adventuringGear: character.inventory?.adventuringGear?.slice(limits.adventuringGear) ?? [],
    };
    
    const hasCharacterOverflow = 
        overflow.features.length > 0 ||
        overflow.attacks.length > 0 ||
        overflow.equipment.length > 0;
    
    const hasSpellOverflow = Object.values(overflow.spells).some(arr => arr.length > 0);
    const hasInventoryOverflow = overflow.adventuringGear.length > 0;
    
    const isSpellcaster = character.spellcasting != null;
    
    if (!fontsReady) {
        return (
            <div className="character-sheet-loading">
                Loading fonts...
            </div>
        );
    }
    
    const containerStyle: React.CSSProperties = {
        '--dm-page-width': `${PAGE_WIDTH_PX}px`,
        '--dm-page-height': `${PAGE_HEIGHT_PX}px`,
        '--dm-page-scale': `${scale}`,
    } as React.CSSProperties;
    
    return (
        <div 
            ref={containerRef}
            className="character-sheet-document"
            style={containerStyle}
        >
            <div 
                className="character-sheet-pages"
                style={{ transform: `scale(${scale})`, transformOrigin: 'top center' }}
            >
                {/* Page 1: Character Main */}
                <CharacterMainPage
                    character={character}
                    limits={limits}
                    isEditMode={isEditMode}
                    onUpdateData={onUpdateData}
                />
                
                {/* Page 1.1: Character Overflow (if needed) */}
                {hasCharacterOverflow && (
                    <CharacterOverflowPage
                        features={overflow.features}
                        attacks={overflow.attacks}
                        equipment={overflow.equipment}
                    />
                )}
                
                {/* Page 2: Spells Main (if spellcaster) */}
                {isSpellcaster && (
                    <SpellMainPage
                        spellcasting={character.spellcasting}
                        limits={limits}
                    />
                )}
                
                {/* Page 2.1: Spell Overflow (if needed) */}
                {isSpellcaster && hasSpellOverflow && (
                    <SpellOverflowPage
                        spellsByLevel={overflow.spells}
                    />
                )}
                
                {/* Page 3: Inventory Main */}
                <InventoryMainPage
                    inventory={character.inventory}
                    currency={character.currency}
                    limits={limits}
                />
                
                {/* Page 3.1: Inventory Overflow (if needed) */}
                {hasInventoryOverflow && (
                    <InventoryOverflowPage
                        adventuringGear={overflow.adventuringGear}
                    />
                )}
            </div>
        </div>
    );
};
```

### 7.2 Key Implementation Differences

| StatblockPage.tsx | CharacterSheetDocument.tsx |
|-------------------|---------------------------|
| `CanvasLayoutProvider` wrapper | No Canvas wrapper |
| `useCanvasLayout()` hook | Simple React state |
| `MeasurementPortal` for heights | No measurement needed |
| `CanvasPage` component | Direct JSX pages |
| Dynamic `layoutPlan.pages` | Fixed page components |
| Canvas owns page count | PCG owns page count |
| Canvas splits lists | PCG slices to limits |

---

## 8. Section Component Props Interface

**Note:** PCG components are simpler than Canvas components because they don't need pagination props.

```typescript
// src/components/PlayerCharacterGenerator/types/componentProps.ts

import type { Character } from '../../../types/dnd5e/character.types';

// Base props for all section components
export interface SectionComponentProps {
    /** Edit mode enables direct field editing */
    isEditMode?: boolean;
    
    /** Callback to update character data */
    onUpdateData?: (updates: Partial<Character>) => void;
}

// Props for bounded sections (show "hasMore" indicator)
export interface BoundedSectionProps extends SectionComponentProps {
    /** Whether more items exist beyond the displayed ones */
    hasMore?: boolean;
    
    /** Title override for continuation sections */
    title?: string;
    
    /** Whether this is a continuation from main page */
    isContinuation?: boolean;
}

// Example: Features section
export interface FeaturesSectionProps extends BoundedSectionProps {
    features: Feature[];
}

// Example: Attacks section
export interface AttacksSectionProps extends BoundedSectionProps {
    attacks: Attack[];
}

// Example: Static section (no hasMore needed)
export interface AbilityScoresRowProps extends SectionComponentProps {
    abilities: AbilityScores;
}
```

---

## 9. Implementation Phases (Updated for Static Approach)

### Phase 0: Foundation & Infrastructure - ~4 hours

**Prerequisites that must complete before other phases:**

1. **Create `CharacterSheetDocument.tsx`**
   - Entry point component
   - Font loading (borrowed from Canvas)
   - Responsive scaling (borrowed from Canvas)
   - Overflow calculation logic
   - Page sequencing

2. **Create `constants/sectionLimits.ts`**
   - Define LIMITS for bounded sections
   - Initially conservative (can adjust based on testing)

3. **Set up CSS infrastructure**
   - Copy/adapt from `phb-prototype.css`
   - Create `CharacterSheet.css` for React components
   - CSS variables for PHB theming

4. **Create base page components (shells)**
   - `CharacterMainPage.tsx` (empty shell)
   - `CharacterOverflowPage.tsx` (empty shell)
   - `SpellMainPage.tsx` (empty shell)
   - `SpellOverflowPage.tsx` (empty shell)
   - `InventoryMainPage.tsx` (empty shell)
   - `InventoryOverflowPage.tsx` (empty shell)

### Phase 1: Character Main Page Sections (Static) - ~8 hours

**All STATIC components (never need overflow):**

1. **HeaderSection** (~1h)
   - Portrait, Name, Class/Level, Background, Race, Alignment, XP
   - Direct port from `character-sheet.html` prototype

2. **AbilityScoresRow** (~1h)
   - 6 ability boxes in horizontal layout
   - Score + modifier display

3. **Column 1 Static** (~2h)
   - TopStatsBox (Inspiration + Prof Bonus)
   - SavingThrowsSection (6 saves)
   - SkillsSection (18 skills)
   - PassivePerceptionBox

4. **Column 2 Static** (~2h)
   - CombatStatsRow (AC, Init, Speed)
   - HPSection (Max, Current, Temp)
   - HitDiceSection
   - DeathSavesSection

5. **Column 3 Static** (~2h)
   - PersonalityBox (4 instances: Personality, Ideals, Bonds, Flaws)

### Phase 2: Character Main Page Sections (Bounded) - ~6 hours

**BOUNDED components (show first N items, overflow rest):**

6. **AttacksSection** (~2h)
   - Show first `limits.attacks` items
   - `hasMore` indicator if more exist
   - Attack rows with name, bonus, damage

7. **EquipmentSection** (~2h)
   - Currency row (5 coins)
   - Show first `limits.equipment` items
   - `hasMore` indicator

8. **FeaturesSection** (~1.5h)
   - Show first `limits.features` items
   - `hasMore` indicator
   - Feature with name + description

9. **ProficienciesSection** (~0.5h)
   - Languages, tools, weapons, armor
   - Usually static, but can overflow

### Phase 3: Character Overflow Page - ~2 hours

10. **CharacterOverflowPage layout** (~2h)
    - Simple continuation list containers
    - `FeaturesSection` with `isContinuation` prop
    - `AttacksSection` with `isContinuation` prop
    - `EquipmentSection` with `isContinuation` prop

### Phase 4: Spell Sheet Pages - ~6 hours

11. **SpellMainPage** (~4h)
    - SpellHeader (class, ability, DC, attack bonus)
    - SpellSlotsRow (9 level trackers)
    - SpellLevelBlock Ã— 10 (Cantrips + 9 levels)
    - Each level bounded to `limits.spellsPerLevel`

12. **SpellOverflowPage** (~2h)
    - Continuation spell lists per level
    - Only levels with overflow render

### Phase 5: Inventory Sheet Pages - ~6 hours

13. **InventoryMainPage** (~4h)
    - InventoryHeader (name, class, strength)
    - CurrencySection, EncumbranceSection, AttunementSection
    - InventoryBlock Ã— N categories (weapons, armor, magic items, gear)
    - ContainerBlock for nested containers

14. **InventoryOverflowPage** (~2h)
    - Continuation lists for each category
    - Only categories with overflow render

### Phase 6: Edit Mode & Integration - ~4 hours

15. **Inline editing** (~2h)
    - Click-to-edit for text fields
    - Spinner/increment for numeric fields
    - Checkbox for proficiency markers

16. **Integration with wizard** (~2h)
    - Connect to CharacterCreationContext
    - Replace existing CharacterSheetRenderer
    - Test data flow

### Total Time Estimate: ~36 hours

| Phase | Hours | Description |
|-------|-------|-------------|
| Phase 0 | 4h | Foundation & Infrastructure |
| Phase 1 | 8h | Character Static Sections |
| Phase 2 | 6h | Character Bounded Sections |
| Phase 3 | 2h | Character Overflow Page |
| Phase 4 | 6h | Spell Sheet Pages |
| Phase 5 | 6h | Inventory Sheet Pages |
| Phase 6 | 4h | Edit Mode & Integration |

---

## 10. Data Flow Diagram (Updated)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CharacterCreationContext                      â”‚
â”‚                    (React Context Provider)                      â”‚
â”‚                                                                  â”‚
â”‚  character: DnD5eCharacter                                       â”‚
â”‚  setCharacter: (updates) => void                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CharacterSheetDocument.tsx                      â”‚
â”‚                  (Entry Point - NO CANVAS WRAPPER)               â”‚
â”‚                                                                  â”‚
â”‚  - Reads character from context                                  â”‚
â”‚  - Calculates overflow: character.features.slice(LIMIT)          â”‚
â”‚  - Orchestrates page sequence                                    â”‚
â”‚  - Applies responsive scaling (borrowed pattern)                 â”‚
â”‚  - Renders page components directly                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Page Components                              â”‚
â”‚                     (Static JSX Layouts)                         â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚CharacterMainPageâ”‚  â”‚  SpellMainPage  â”‚  â”‚InventoryMainPageâ”‚    â”‚
â”‚  â”‚                â”‚  â”‚                â”‚  â”‚                â”‚    â”‚
â”‚  â”‚ - Static layoutâ”‚  â”‚ - Static layoutâ”‚  â”‚ - Static layoutâ”‚    â”‚
â”‚  â”‚ - 3 columns    â”‚  â”‚ - 3 columns    â”‚  â”‚ - 3 columns    â”‚    â”‚
â”‚  â”‚ - Bounded itemsâ”‚  â”‚ - Bounded itemsâ”‚  â”‚ - Bounded itemsâ”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚          â”‚                   â”‚                   â”‚              â”‚
â”‚          â†“                   â†“                   â†“              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚CharOverflowPageâ”‚  â”‚SpellOverflowPageâ”‚  â”‚InvOverflowPage â”‚    â”‚
â”‚  â”‚ (if hasOverflow)â”‚  â”‚ (if hasOverflow)â”‚  â”‚ (if hasOverflow)â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Section Components                            â”‚
â”‚                    (Reusable React Components)                   â”‚
â”‚                                                                  â”‚
â”‚  Static:                    Bounded:                             â”‚
â”‚  - HeaderSection            - AttacksSection(attacks, hasMore)   â”‚
â”‚  - AbilityScoresRow         - FeaturesSection(features, hasMore) â”‚
â”‚  - SavingThrowsSection      - EquipmentSection(items, hasMore)   â”‚
â”‚  - SkillsSection            - SpellLevelBlock(spells, hasMore)   â”‚
â”‚  - CombatStatsRow                                                â”‚
â”‚  - DeathSavesSection                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 11. Success Criteria (Updated)

### Architecture âœ…
- [ ] `CharacterSheetDocument.tsx` orchestrates page sequence
- [ ] Static pages render without Canvas measurement
- [ ] Overflow detection uses simple slice operations
- [ ] Font loading borrowed from Canvas pattern
- [ ] Responsive scaling borrowed from Canvas pattern

### Visual âœ…
- [ ] Matches PHB character sheet aesthetic (from HTML prototypes)
- [ ] PHB fonts load correctly (NodestoCaps, ScalySans, BookInsanity)
- [ ] Parchment backgrounds apply correctly
- [ ] Monster border frame on page edges
- [ ] 3-column layout matches `character-sheet.html` prototype

### Functional âœ…
- [ ] Auto-calculation works (modifiers, bonuses, etc.)
- [ ] Spellcasting pages render only for spellcasters
- [ ] Bounded sections show first N items, overflow pages show rest
- [ ] "Has more" indicators show when content continues
- [ ] Edit mode enables inline field editing

### Print âœ…
- [ ] Each page is a complete, printable unit
- [ ] Page breaks between Character/Spell/Inventory
- [ ] Backgrounds print with `print-color-adjust: exact`
- [ ] PHB footer accent appears at bottom

### Performance âœ…
- [ ] Main pages render immediately (no measurement wait)
- [ ] Only overflow pages might trigger Canvas (optional)
- [ ] Font loading gated before render

---

## 12. File Structure (Updated)

```
LandingPage/src/components/PlayerCharacterGenerator/
â”œâ”€â”€ CharacterSheetDocument.tsx           # NEW: Entry point orchestrator
â”œâ”€â”€ characterAdapters.ts                 # EXISTS: May update for overflow
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ sectionLimits.ts                 # NEW: Bounded section limits
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ CharacterMainPage.tsx            # NEW: Static 3-column layout
â”‚   â”œâ”€â”€ CharacterOverflowPage.tsx        # NEW: Continuation lists
â”‚   â”œâ”€â”€ SpellMainPage.tsx                # NEW: Static spell layout
â”‚   â”œâ”€â”€ SpellOverflowPage.tsx            # NEW: Spell continuations
â”‚   â”œâ”€â”€ InventoryMainPage.tsx            # NEW: Static inventory layout
â”‚   â””â”€â”€ InventoryOverflowPage.tsx        # NEW: Inventory continuations
â”œâ”€â”€ sections/
â”‚   â”œâ”€â”€ HeaderSection.tsx                # NEW: Portrait + info boxes
â”‚   â”œâ”€â”€ AbilityScoresRow.tsx             # NEW: 6 ability boxes
â”‚   â”œâ”€â”€ TopStatsBox.tsx                  # NEW: Inspiration + Prof Bonus
â”‚   â”œâ”€â”€ SavingThrowsSection.tsx          # NEW: 6 saves
â”‚   â”œâ”€â”€ SkillsSection.tsx                # NEW: 18 skills
â”‚   â”œâ”€â”€ PassivePerceptionBox.tsx         # NEW: Single value
â”‚   â”œâ”€â”€ CombatStatsRow.tsx               # NEW: AC, Init, Speed
â”‚   â”œâ”€â”€ HPSection.tsx                    # NEW: HP tracking
â”‚   â”œâ”€â”€ HitDiceSection.tsx               # NEW: Hit dice tracker
â”‚   â”œâ”€â”€ DeathSavesSection.tsx            # NEW: Death save circles
â”‚   â”œâ”€â”€ AttacksSection.tsx               # NEW: Bounded attacks
â”‚   â”œâ”€â”€ EquipmentSection.tsx             # NEW: Bounded equipment
â”‚   â”œâ”€â”€ PersonalityBox.tsx               # NEW: Trait/Ideal/Bond/Flaw
â”‚   â”œâ”€â”€ FeaturesSection.tsx              # NEW: Bounded features
â”‚   â”œâ”€â”€ ProficienciesSection.tsx         # NEW: Languages, tools, etc.
â”‚   â”œâ”€â”€ NotesSection.tsx                 # NEW: Free-text notes
â”‚   â”œâ”€â”€ SpellHeader.tsx                  # NEW: Class, ability, DC
â”‚   â”œâ”€â”€ SpellSlotsRow.tsx                # NEW: 9 level trackers
â”‚   â”œâ”€â”€ SpellLevelBlock.tsx              # NEW: Bounded spell list
â”‚   â”œâ”€â”€ CurrencySection.tsx              # NEW: 5 coin types
â”‚   â”œâ”€â”€ EncumbranceSection.tsx           # NEW: Weight tracking
â”‚   â”œâ”€â”€ AttunementSection.tsx            # NEW: 3 attunement slots
â”‚   â””â”€â”€ InventoryBlock.tsx               # NEW: Category item list
â”œâ”€â”€ types/
â”‚   â””â”€â”€ componentProps.ts                # NEW: Section props interfaces
â”œâ”€â”€ styles/
â”‚   â””â”€â”€ CharacterSheet.css               # NEW: Adapted from phb-prototype.css
â””â”€â”€ hooks/
    â””â”€â”€ useCharacterOverflow.ts          # NEW: Overflow calculation hook
```

---

## 13. References (Updated)

### HTML Prototypes (Source of Truth for Visual Design)
- `specs/PlayerCharacterGenerator/prototypes/character-sheet.html`
- `specs/PlayerCharacterGenerator/prototypes/spell-sheet.html`
- `specs/PlayerCharacterGenerator/prototypes/inventory-sheet.html`
- `specs/PlayerCharacterGenerator/prototypes/phb-prototype.css`

### Analysis Documents
- `specs/PlayerCharacterGenerator/ANALYSIS-Page-Layout-Components.md` - Static vs Dynamic classification

### Canvas Documentation (Patterns to Borrow)
- `Docs/architecture/Canvas_Architecture.md` - Font loading, scaling patterns
- `Docs/Guides/GUIDE-Canvas-Component-Building.md` - Component patterns
- `StatblockPage.tsx` - Reference for font loading, responsive scaling

### D&D Assets
- `public/dnd-static/themes/fonts/5e/` - PHB fonts
- `public/dnd-static/themes/assets/` - Borders, backgrounds

---

## 15. Lessons Applied from StatblockGenerator & Canvas

The following lessons from the StatblockGenerator rebuild and Canvas extraction directly inform this design:

### 15.1 Architecture Lessons (Critical)

#### âœ… APPLY: Font Loading Race Condition Prevention

**Lesson (StatblockGenerator):** Measurements taken before fonts load are wrong by 80%+.

**Application to PCG:**
```typescript
// CharacterSheetDocument.tsx - COPY THIS PATTERN
useLayoutEffect(() => {
    const loadFonts = async () => {
        await Promise.all([
            document.fonts.load('700 24px NodestoCapsCondensed'),
            document.fonts.load('400 14px ScalySansRemake'),
            document.fonts.load('700 14px ScalySansRemake'),
            document.fonts.load('400 14px BookInsanityRemake'),
        ]);
        await document.fonts.ready;
        setFontsReady(true);
    };
    loadFonts();
}, []);

// DO NOT RENDER until fontsReady === true
if (!fontsReady) return <Loading />;
```

**Why This Matters for PCG:** We're using the same PHB fonts. Without this, the first render will flash wrong fonts.

---

#### âœ… APPLY: ID-Based List Management

**Lesson (StatblockGenerator):** Using array indices for React keys broke edit/delete operations.

**Application to PCG:**
```typescript
// REQUIRED: All list items must have stable IDs from backend
interface Attack {
    id: string;  // Required, backend-generated
    name: string;
    bonus: number;
    damage: string;
}

// In components
{attacks.map(attack => (
    <AttackRow key={attack.id} attack={attack} />  // NEVER key={index}
))}

// Updates use ID, not index
const updateAttack = (id: string, updates: Partial<Attack>) => {
    setAttacks(prev => prev.map(a => a.id === id ? {...a, ...updates} : a));
};
```

**PCG Lists That Need IDs:**
- `character.attacks` â† each attack needs `id`
- `character.features` â† each feature needs `id`
- `character.equipment` â† each item needs `id`
- `character.spellcasting.spellsByLevel[n]` â† each spell needs `id`
- `character.inventory.adventuringGear` â† each item needs `id`

---

#### âœ… APPLY: useState vs useRef for Guard Flags

**Lesson (StatblockGenerator):** `useState` is async; callbacks see old values.

**Application to PCG:** For edit mode, overflow calculations, and animation guards:
```typescript
// âŒ WRONG: Async state causes race conditions
const [isEditing, setIsEditing] = useState(false);

// âœ… CORRECT: Ref updates immediately for guard checks
const isEditingRef = useRef(false);

const handleEditComplete = () => {
    isEditingRef.current = false;  // Immediate
    recalculateOverflow();  // Callback sees updated value
};
```

---

#### âœ… APPLY: Explicit CSS Units (px, not em/rem)

**Lesson (Canvas):** `em` units cause measurement drift because they're font-size dependent.

**Application to PCG:**
```css
/* âŒ AVOID in layout-critical styles */
.section { margin: 0.5em; padding: 1rem; }

/* âœ… USE px for structural spacing */
.section { margin: 8px; padding: 16px; gap: 12px; }
```

**Exception:** Typography that doesn't affect layout can use `rem` for accessibility.

---

### 15.2 Process Lessons (Apply to Implementation)

#### âœ… APPLY: Consumer Before Producer

**Lesson (PCG prior work):** Build display first, then wizard.

**Application:**
1. Phase 1-5: Build display components (consumer of character data)
2. Phase 6: Integrate with wizard (producer of character data)
3. Use `DEMO_FIGHTER.ts` fixture to test components before wizard integration

**Why:** Displays validate the data model faster than producers.

---

#### âœ… APPLY: Pop-Out Edit Effect (Container Focus)

**Lesson (StatblockGenerator):** Entire sections should pop when editing, not individual fields.

**Application to PCG:**
```css
/* Pop-out on ANY child receiving focus */
.attacks-section:focus-within {
    transform: scale(1.05);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    z-index: 100;
    transition: all 0.2s ease;
}

/* Individual editable elements have NO special styling */
[contenteditable] {
    position: static !important;  /* Don't escape parent */
}
```

**Component Requirement:** Always wrap editables in a container div (never use fragments).

---

#### âœ… APPLY: 2-Second Edit Timer

**Lesson (StatblockGenerator):** Defer layout updates until 2s after editing stops.

**Application to PCG:** Not strictly needed for main pages (static layout), but useful for overflow recalculation:
```typescript
const editTimerRef = useRef<NodeJS.Timeout | null>(null);

const handleEditChange = () => {
    // Reset timer on each change
    if (editTimerRef.current) clearTimeout(editTimerRef.current);
    editTimerRef.current = setTimeout(() => {
        // Recalculate overflow after editing stops
        recalculateOverflow();
    }, 2000);
};
```

---

### 15.3 Lessons We DON'T Need to Apply

Because PCG uses static pages instead of Canvas pagination, several lessons don't apply:

| Lesson | Why Not Applicable |
|--------|-------------------|
| Measurement layer CSS matching | No measurement layer |
| Column padding in pagination | No Canvas pagination |
| Region height calculations | Static pages, not regions |
| Stale measurement cache | No measurement caching |
| CSS gap in cursor advance | No cursor/pagination |
| Scale factor in getBoundingClientRect | Only for responsive, not measurement |
| Portal font-size context | No measurement portal |

**Key Insight:** By choosing static pages, we've **eliminated the entire class of measurement bugs** that plagued StatblockGenerator development.

---

### 15.4 Risk Mitigation from Lessons

| Risk | Lesson Source | Mitigation |
|------|---------------|------------|
| Fonts flash wrong on first load | Canvas font loading | Gate render on `fontsReady` |
| Edit/delete breaks with index keys | StatblockGenerator IDs | Require backend IDs on all lists |
| Race conditions in callbacks | useState vs useRef | Use `useRef` for guard flags |
| Layout drift on edit | em units | Use px for structural CSS |
| Overflow not updating | Edit timer pattern | 2-second debounce on edit changes |
| Components escape parent on focus | Pop-out pattern | Wrap all editables in containers |

---

### 15.5 Code Patterns to Copy Directly

**From StatblockPage.tsx:**
```typescript
// 1. Font loading (copy exactly)
useLayoutEffect(() => {
    const checkFonts = async () => {
        await Promise.all([
            document.fonts.load('700 24px NodestoCapsCondensed'),
            document.fonts.load('400 14px ScalySansRemake'),
            document.fonts.load('700 14px ScalySansRemake'),
        ]);
        await document.fonts.ready;
        await new Promise(resolve => {
            requestAnimationFrame(() => requestAnimationFrame(resolve));
        });
        setFontsReady(true);
    };
    checkFonts();
}, []);

// 2. Responsive scaling (copy exactly)
useLayoutEffect(() => {
    const observer = new ResizeObserver((entries) => {
        const width = entries[0].contentRect.width;
        const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, width / PAGE_WIDTH_PX));
        setScale(newScale);
    });
    observer.observe(containerRef.current);
    return () => observer.disconnect();
}, []);
```

**From StatblockComponents.css:**
```css
/* Pop-out effect (adapt class names) */
.phb-section:focus-within {
    transform: scale(1.08);
    box-shadow: 0 12px 48px rgba(0, 0, 0, 0.3);
    background: rgba(255, 255, 255, 0.98);
    border: 1px solid var(--mantine-color-blue-5);
    z-index: 100;
    transition: all 0.2s ease;
}
```

---

## 16. Design Status

**Status:** ğŸ”’ LOCKED - Ready for Implementation  
**Date Locked:** December 5, 2025

### Key Decisions Locked

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Canvas role | Pattern library, not layout engine | Static pages don't need measurement |
| Page architecture | Fixed page types + overflow pages | Predictable, printable |
| Overflow strategy | Slice-based (limits) | Simple, no Canvas needed |
| Font loading | Borrow Canvas pattern | Proven, works |
| Responsive scaling | Borrow Canvas pattern | Proven, works |

### Next Steps
1. âœ… Design locked
2. Begin Phase 0 (Foundation)
3. Convert HTML prototypes to React sections


