Foundry D&D5E System Architecture and Data Structure
Entity Model: The D&D5E system for Foundry VTT organizes game content into Actors and Items, using Foundry’s core entity model. Player characters (and NPCs/monsters) are Actors, while almost everything about them – classes, races (often termed “species” in newer content), backgrounds, feats, spells, equipment, features – is represented as Items embedded in the actor. For example, a character’s class levels are tracked by a “Class” item on that actor, the chosen race is a “Race” item, and each class feature, feat, or spell is an Item in the actor’s inventory/feature tabs. This design means the rules content is largely data-driven: the system comes with compendium packs containing SRD definitions for all classes, subclasses, races, spells, items, etc.. These packs are JSON data (the SRD 5.1/5.2 content under WotC’s OGL/CC license) and can be extracted or used independently of the Foundry software – a big plus for reuse. (For instance, there are compendiums for “Classes (SRD)”, “Class Features (SRD)”, “Races (SRD)”, “Spells (SRD)”, etc., each with all the textual data and stats needed.)
Code Structure: The repository is organized into several folders, notably: module/ (the JavaScript/ESM source code for the system), templates/ (Handlebars HTML templates for character sheets and other UI), packs/ (the compendium data, often provided in a _source format for the JSON content), and utils/ (utility scripts). The runtime logic is primarily in the module folder. There, the system defines custom classes like Actor5e and Item5e which extend Foundry’s base Actor and Item classes to implement D&D5E-specific behavior[1][2]. For example, Actor5e is declared as:
export default class Actor5e extends SystemDocumentMixin(Actor) { … }
and Item5e similarly extends the base Item. These classes override or extend core methods to enforce game mechanics – e.g., handling how rolls are made, how data is prepared, or how adding an item affects the character. In addition, there are specialized classes for data modeling. Foundry VTT v10+ introduced DataModel classes for document data, and the 5e system defines schema models for each item type. In module/data/item/ you’ll find files like class.mjs, race.mjs, background.mjs, etc., which define the fields and nested structures that those item types use[3][4]. For instance, the Class item’s data schema includes fields for hit dice, class level, primary ability, proficiencies, spellcasting progression, and an advancement array that enumerates class features gained per level[4][5]. This separation of data schema is useful – it means the raw definitions of what a “Class” contains (e.g. hd.denomination for hit die type, levels, spellcasting.progression and ability, etc.) are written in a modular way. A standalone application could reuse these schemas (they’re defined in plain JS, not requiring Foundry at runtime) as a blueprint for its own data structures.
Notably, the system’s data design treats things like class features and racial traits as Items (often of type “feat”). A Class item in the compendium doesn’t list all features by text; instead it has an advancement table linking to those feature items. The Foundry 5e system recently introduced a robust Advancement mechanic to automate character progression. Each Class or Subclass item contains an array of advancement entries (level milestones) that specify what happens at that level – e.g. “at level 2, gain the ‘Action Surge’ feature item” or “at level 4, gain an Ability Score Improvement choice”[6]. These entries can also prompt the user for choices (such as which subclass to pick at a certain level, or which skill proficiencies to gain from a class’s starting options). This advancement data is part of the item’s system data and is extremely useful for a character builder – it’s basically an encoded form of the leveling rules. A lot of the rule enforcement is implemented by this data + code combo: the data declares what should happen, and the code in the system triggers an interactive workflow to apply those changes to the Actor.
Rule Enforcement Logic and Reusable Components
Character Creation & Level-Up Workflow: When you add a Class item to a character or increase its levels, the Foundry system launches a step-by-step advancement dialog. This is handled by the AdvancementManager and related UI classes in module/applications/advancement/ (coupled to Foundry’s Application framework). It reads the class’s advancement array and walks the user through each item: e.g., rolling hit points, gaining class features, choosing subclass or optional features at the appropriate levels. The logic ensures, for example, that when a subclass is chosen, its features appropriate to the current class level are immediately granted. (In the current 5e system, subclass selection was to be further automated in a future update – but as of the cited version, the recommended approach is to drag a Subclass item onto the character after reaching the level that grants it.)
From a reuse perspective, the advancement system is one of the most valuable pieces. The data for advancements (which lives in the class/subclass items) could be directly ported into a new tool – it effectively encodes the class progression tables from D&D5e. You would likely need to write your own logic to interpret that data (since Foundry’s AdvancementManager is intertwined with Foundry APIs), but you can follow the same structure. For example, an advancement entry of type “ItemGrant” at level 3 might say “grant item X (the subclass feature)”; your standalone app could read that and know to add the corresponding feature to the character at the right time. The Foundry 5e code already handles ensuring that if a class is removed or leveled down, the granted items are removed as well – your implementation could mirror this behavior.
Rules Enforcement and Validation: It’s important to note that the Foundry 5e system does not rigidly enforce all character creation rules – it guides them. For instance, there is no hard check preventing you from dragging a second Class onto a character without meeting multiclass prerequisites; the system leaves such rule policing to the user or the GM (or perhaps a module). Similarly, you could technically add two Background items or multiple Race items to an actor – the system UI isn’t designed for that (and it would be odd in the data model), but there’s nothing in code that outright forbids it. The philosophy is to provide the structure and information (e.g., marking which ability is a class’s primary for multiclass, listing feat prerequisites in the description, etc.) rather than lock the interface. So, validation logic in the code is minimal – you won’t find functions that say “reject adding this feat because prerequisites not met.” What you will find are convenience computations and state tracking to support rule implementation. For example, the Actor5e preparation logic automatically calculates things like a Wizard’s number of prepared spells (based on their class level and INT mod), or a character’s proficiency bonus based on total level[7][8].
Game Mechanics Calculations: Many core 5e mechanics are implemented in the Actor5e and Item5e classes in a way that could be lifted or reimplemented with reference to the code:
    • Proficiency Bonus: The system computes proficiency based on character level and items. The Actor’s data has system.attributes.prof which is the proficiency bonus. In Foundry 5e, this is set during data preparation: e.g., a level 5 character gets prof = 3. The code for this is straightforward and not strictly hard-coded – it derives from a table or formula (level/4 rounded up, etc.). In fact, the system’s Proficiency helper (in actor/proficiency.mjs) can produce modified proficiency terms (like half or double proficiency) as needed[9][10]. Reusing the formulae here is trivial since 5e’s proficiency progression is well-known, but you can double-check your implementation against the system’s behavior (ensuring, for instance, that temporary effects that modify proficiency – like Jack of All Trades (half prof) – are accounted for via that Proficiency helper).
    • Abilities, Skills, Saves: The system defines the standard 6 abilities and dozens of skills in its config (usually in a JSON or JS config object CONFIG.DND5E). Abilities are identified by keys "str","dex",... and skills by e.g. "ins" (Insight) etc. These are mostly data dictionaries that you can copy. The Actor5e class provides methods like rollAbilityTest, rollSkill, rollSavingThrow which pull the correct ability mods, proficiency, and any situational bonuses[11][12]. Those methods call into Foundry’s Dice system to actually roll and report results. In a standalone app, you’d not literally reuse those methods (since they depend on Foundry’s roll evaluator and chat log), but you can reuse the logic for how totals are calculated. For example, a skill check in Foundry 5e is essentially d20 + abilityMod + proficiencyBonus(if proficient) + expertiseBonus(if any) + miscellaneous bonuses. The code for these calculations is available and can guide your implementation of a roller or a validator that ensures the totals match.
    • Spellcasting & Multiclass Slots: This is a complex area that the Foundry system handles elegantly. Each Class item’s data indicates its spellcasting progression – e.g., a Wizard has spellcasting.progression = "full" and spellcasting.ability = "int" (for INT-based full caster), a Paladin might be "half" progression and CHA-based (if we assume half casters use CHA in this hypothetical, just an example), a Warlock has progression = "pact" (special progression). The system defines in CONFIG.DND5E.spellProgression and CONFIG.DND5E.spellcasting the rules for these progressions (how to combine them)[13][14]. In code, when an Actor’s data is prepared, it calls an internal _prepareSpellcasting() method that:
    • Looks at all class items on the actor that grant spellcasting,
    • Sums up their contributions to a spell slot progression depending on type (e.g., two “full” casters count all their levels each, a “half” caster contributes half levels, rounding down, etc., per D&D multiclass rules),
    • Determines the character’s overall spellcaster level and slot count, and then populates the Actor’s spell slots (e.g. system.spells.slot1.max = 4, etc.)[15][16].
This logic is certainly reusable with some work. The Foundry code uses a combination of data + functions: it has preset progression tables and a function that computes the “effective caster level” for slot progression. By studying Actor5e.computeClassProgression and the SpellcastingModel implementations, you can extract the rule: the code essentially replicates the multiclass spell slot rules from PHB (e.g., add up full caster levels + half of half-caster levels, etc.)[17][18]. Rewriting this in TypeScript is feasible and you can even use the same progression data (the tables for how many slots at each level) since those are part of the open content. After computing slot progression, the system sets the Actor’s spell slot resources accordingly[19]. It even accounts for Warlock Pact Magic slots separately (using a separate “pact” progression model). All of this is done without requiring Foundry beyond using the data; you could pull the JSON or JS object that lists slots per level (Foundry likely stores it in dnd5e.js or config.js) and leverage it directly.
    • Item Effects and Equipment: The system also encodes many item-based rules. Armor items, for example, have data for their base AC and whether they impose a Dex modifier cap or disadvantage on stealth. The Actor’s data preparation will loop through worn armor and compute the effective AC. Similarly, weapons have properties that affect critical range or versatile damage – these are handled via either data or minimal logic in the Item5e class. Much of this is again encapsulated in data definitions (e.g., weapon property definitions in CONFIG.DND5E.weaponProperties). You can reuse those tables and the general approach: Foundry 5e doesn’t hard-enforce that you must have proficiency X to use a weapon, but it will mark it on the sheet and include or exclude proficiency bonus in attack rolls accordingly. That logic (check item’s proficient flag vs. actor’s proficiencies) can be ported.
Active Effects: One tightly-coupled aspect is Foundry’s Active Effect system, which the D&D5E module leverages to apply certain dynamic modifiers. For example, equipping a Belt of Giant Strength might apply an Active Effect that sets your STR score to 21. In Foundry, this happens automatically when you equip the item (the item has an embedded effect that the system knows how to apply). In a standalone project, you likely won’t have a full Active Effects engine out of the box. You’d have to decide whether to implement a similar concept (effects that modify character stats on the fly) or simply calculate outcomes directly. The Foundry 5e code can serve as a reference for what kinds of effects need to be considered – e.g., conditions (blinded, prone) are implemented as status effects that affect rolls via global advantages/disadvantages. If you do want an Active Effect system, you could mimic Foundry’s data structure: each effect has a key (like system.abilities.str.value), a mode (OVERRIDE, ADD, MULTIPLY, etc.), and a value to apply[20]. The D&D5E system defines a bunch of preset effects for conditions in its CONFIG.DND5E.conditionTypes and applies them when conditions are added. Reusing this requires more effort, but at least the list of condition effects (e.g., Restrained imposes disadvantage on Dex saves, etc.) could be harvested from the system’s JSON translations or documentation.
Coupling with Foundry Core APIs
While the conceptual structure of the D&D5E system is clean and modular, the implementation is tightly interwoven with Foundry VTT’s APIs. Directly lifting the code into a standalone app will not work without substantial modification, because many calls assume the Foundry runtime. Here are some points of tight coupling:
    • Foundry Document Model: As noted, Actor5e and Item5e are subclasses of Foundry’s Actor and Item. They rely on base class functionality (for storing data, updating, embedding documents, etc.). For example, the code frequently calls things like this.update({...}) or uses this.items (which is a Collection of Items managed by Foundry’s Document framework). In a standalone project, you won’t have this infrastructure. You’ll likely design your own classes or data structures for characters and for item templates. You can still use the same data fields – e.g., have a Character class in TS with a list of ClassLevels – but you’ll not carry over the inheritance. The SystemDocumentMixin that Foundry uses for system data is also not portable – it’s an internal foundry abstraction for new DataModel handling.
    • Foundry game and UI: The system code accesses the global game object for things like configuration and i18n. For example, game.i18n.localize("DND5E.FEAT") to get a localized string, or referencing game.settings for certain optional rules toggles. In a different environment, you’ll have to strip or replace these. Similarly, the UI dialogs (Advancement prompts, roll dialogs, item sheets) are built with Foundry’s Application and FormApplication classes. You won’t reuse that code directly – you’ll build your own UI – but you can mimic their workflow logic. The sequence of steps the Foundry D&D5E system takes for leveling up is clearly documented (and visible in the code), which can serve as a blueprint for your UI flow.
    • Hooks and Events: Foundry’s event system (Hooks) is used throughout the D&D5E code to allow modules or other parts of the system to intervene. For instance, when computing spell slot progression, it calls a hook Hooks.call("dnd5e.computeSpellcastingProgression", ...) that modules could use to modify spell slot calculations[21][18]. In your standalone project, you might not need an event system at first, but be aware that some of the complexity in the code is to support extensibility. If you see code paths that seem complex, it might be due to allowing override by modules (e.g., the code checks for deprecated alternative implementations before defaulting to its own in several places[22][23]). You can simplify those when porting – you have control over the environment, so you may not need those indirections.
    • Foundry-specific Data Constructs: Some data in the compendiums might include Foundry-specific fields. For example, items have _id fields, folder associations, or flags that are only relevant in Foundry. The core rule data, however, is usually under the system key of the document. Those system fields (like system.damage for a weapon’s damage formula, or system.levels for class level) are what you care about. When reusing the compendium JSON, you’d strip out things like _id, permission, ownership, and maybe the img paths (unless you want to use their icons). This is not a heavy burden – it’s mostly cleaning the JSON. Data linking is something to watch for: in the compendium, a class’s feature might just be an item in the Class Features pack with no direct reference back to the class, apart from perhaps name or a snippet in the description. The Foundry system uses the advancement array to tie them together (class advancement says “add Feature X by name or ID”). You’ll need to replicate that lookup. Fortunately, in the 5e SRD, feature names are unique enough within a class context (e.g., “Divine Domain” belongs to cleric, etc.), and the compendium likely uses unique IDs – the advancement entries might actually reference those UUIDs. If they do (some entries might use itemUuid or similar), you can use that as a key to fetch the right data from your dataset.
In summary, the logic is modular in intention but not in extraction. You can’t simply import Foundry’s JS and run it in a browser without Foundry. However, you can methodically translate it: convert the data models to TypeScript interfaces/classes, copy the pure functions (like certain utilities in utils.mjs) and adjust them to not use Foundry globals, and use the compendium JSON as seed data. The Dice rolling and Chat aspects of the system are one area you likely won’t need – a char builder might not require simulating die rolls or chat messages that Foundry has. You can ignore those parts of the code (e.g., anything in rollAbilityCheck or damage calculations) unless your app will also handle rolling.
Data Reuse and Licensing Considerations
One huge advantage of using the Foundry D&D5E system as a foundation is that all the D&D 5e SRD content is included and organized. You do not have to manually create datasets for classes, spells, items – you can lift them from the compendiums. The content is released under the Creative Commons Attribution 4.0 License, per Wizards’ SRD 5.1/5.2 terms, and the software code of the system is under MIT License. This means legally you are free to use, modify, and redistribute that code and data in your own project, so long as you adhere to the license conditions (e.g. include the MIT license notice somewhere in your project and give credit for the CC content). The Foundry team explicitly notes these licenses in the README and even in the system manifest. For example, the manifest (system.json) calls out the use of SRD 5.1 and 5.2 content and the CC-BY license, and the README states: “The software component of this system is distributed under the MIT license.”. So from a licensing perspective, you’re in the clear to reuse any part of it – just remember to attribute the SRD content (typically a link or note citing “Contains content from SRD 5.1/5.2 by Wizards of the Coast, CC BY 4.0”).
Third-Party Dependencies: The system doesn’t rely on external libraries; it’s all self-contained or uses Foundry’s core. So you won’t encounter hidden dependency issues porting it, beyond the need to replace Foundry’s functionality. One thing to watch is if your project is open source, you’ll need to exclude any non-SRD content. The Foundry 5e system itself is careful about this, only including OGL/OGL-like content. (For instance, it has “Starter Heroes” which are just SRD sample characters, not anything proprietary.) If you wanted beyond-SRD (like full class descriptions, subclasses from supplements, etc.), you’d have to source those separately (they’re not in the repo due to WotC’s licensing).
Effort to Decouple: Given all the above, how much work is it to adapt? In broad terms: Using the data: very easy (mostly copy JSON and adjust format). Using the logic: moderate to high effort, because you’ll essentially be re-writing it in a new environment. The most reusable logic with minimal changes will be things like formulas and data definitions. For example, you could literally copy the object that defines all skill names and their associated ability (Foundry has CONFIG.DND5E.skills mapping “ath” -> Athletics -> STR) – that’s just a JS object. Same for weapon categories, armor types, conditions, etc., which are likely defined in some JSON under lang/en.json or in config. Reusing those saves time and ensures you align with the 5e rules as implemented.
On the other hand, things like the character sheet UI (which is a Handlebars template with specific layout and toggles) are not directly reusable – but you might not need them if you’re creating a custom interface. You can design your own UI but refer to the sheet to see which fields are exposed and how (ensuring you don’t miss, say, the “ Inspiration” toggle or the death save tracker, etc.).
Key Modules/Files to Examine for Reuse:
    • Data Files: The JSON in packs/ – especially classes.db, classfeatures.db, backgrounds.db, races.db, spells.db, items.db. In the GitHub repo, these are often provided in human-readable form under packs/_source/ as individual .json files for each entry. These are gold for populating your rule engine’s database. You will get things like the full text of each spell (if from SRD), the attributes of each class (hit die, proficiencies, etc.), and even pre-defined starting equipment packages for classes.
    • system.json: Lists the item and actor types and other high-level config. For instance, it defines that item types “class”, “subclass”, “race”, “background”, etc. exist, and even which compendium pack each type’s SRD content is in. This file can be a roadmap of what content to expect and how it’s categorized.
    • Item Data Models: As seen in module/data/item/*.mjs. Particularly class.mjs (class schema)[4], subclass.mjs, race.mjs, feat.mjs, spell.mjs, background.mjs. Reading these will tell you exactly what fields you should store for each entity. For example, race might include things like speed, size, and any special trait notes; background might include skill proficiencies granted, etc. In Foundry 5e, some of those (like skill profs from background) were earlier just textual or manually applied, but with the advancement system, even background could theoretically use an advancement entry (e.g., “Gain Skill Proficiency: Perception”). The feat item model is also interesting – it’s used generically for features and traits. Feats have a field for prerequisites (just text in SRD) and possibly an “activation” info if they can be activated. The Foundry system uses the same item type “feat” for things like class features and racial traits, not just optional feats, so it’s a broad category.
    • Actor & Item Class Code: module/documents/actor/actor.mjs and module/documents/item.mjs (plus their helpers in subfolders) are where the runtime logic lives. Key things to look at:
    • Actor.mjs: the prepareData() method and anything to do with computing stats. This shows how ability scores, proficiencies, HP, AC, etc. are derived[24][25]. It also includes the roll methods, which you may not need, and some transformation mechanics (polymorph, wild shape) which are edge cases.
    • Item.mjs: this file is huge because it handles all item types in one class via type-specific branches. It defines certain getters that make rule enforcement easier. For example, Item5e has a getter isStackable or canEquip, and logic in its onCreate or onUpdate to auto-calculate things like derived damage for weapons. Notably, it also handles linking class and subclass: an Item5e that is a subclass is linked to its parent class item on the actor via an internal reference _classLink (so the code can find “what class does this subclass belong to”)[26]. It may be worth replicating that concept: e.g., in your data model, each subclass knows its parent class (the Foundry data has system.classIdentifier on subclasses, which matches the parent class’s system.identifier)[27][28]. The system uses a normalized identifier (like "fighter" or "wizard") for each class to make this link, instead of by name, which is smart because it’s language-agnostic. You can absolutely take the same approach – these IDs are in the data (if not, the code formatIdentifier(this.name) ensures a consistent slug is used[29]).
    • Advancement Classes: In module/documents/advancement/*.mjs you’ll find implementations of different advancement types (ItemGrant, HitPoints, Choice, Trait, etc.). These show how the system interprets those advancement entries. For example, a “Trait” advancement is used to grant proficiency choices (as seen in the class migration code converting old data to new[5][30]). Looking at these will inform how you present those choices in a UI.
Feasibility and Effort: In practical terms, extracting the data definitions and rule calculations is very feasible. You have a comprehensive reference – essentially the open-source rule engine of Foundry’s D&D5E. Many community developers have even created type definitions (in TypeScript) for the Foundry 5e system, which could accelerate building a TS project (for instance, the GitHub repo foundry-vtt-dnd5e-types provides TS interfaces for the data structures). The effort will be in stripping away the Foundry-specific parts. Expect to rewrite things like data storage, state management, and UI interactions. But you do not have to “reinvent” the 5e rules – the repository has done that heavy lifting.
To give a conclusive example: Can you reuse code to validate a character build? Partially. You can reuse the data-driven approach of Foundry’s system. Instead of writing a big function that checks “did the user pick 2 skills from the class’s list?” you can utilize the class’s advancement info which already encodes “choose 2 from these skills” (the Foundry advancement of type Trait for skill proficiency does exactly that[31][32]). Your app can read that and enforce the choice. However, you won’t find a single function in the system that you can copy-paste to enforce all creation rules at once – it’s more about using the provided structure to guide the user and validate incrementally.
Licensing summary: The MIT license on the code means you can copy any code you find useful, just include the original license in your project’s acknowledgments or LICENSE file. The CC-BY-4.0 license on the content means you must credit the source (usually a line in your about or documentation like “D&D 5th Edition SRD content © Wizards of the Coast, used under CC BY 4.0”). Neither license is viral (unlike GPL); they won’t force your whole project to be open source. They just require attribution and that you pass along the license text for MIT code if distributed. The Foundry core software is NOT open-source, but you won’t be using Foundry itself – you’re just using this game system which is open. So there’s no dependency on Foundry’s code beyond understanding it – you won’t be bundling Foundry APIs (and indeed you cannot, legally, since Foundry is proprietary). But as long as you re-implement rather than embed Foundry’s non-open code, you’re fine.
Finally, since the question is specifically about a TypeScript-based front-end project for character generation and rule validation, the approach would be: use TS to define data models (Classes, Races, etc.) according to Foundry’s schema, load the JSON data for SRD content into those models, and then write functions (or services) to handle things like adding a class to a character (consult the class’s advancement entries, apply features, etc.), leveling up, checking for errors (e.g., if a character has two subclasses for the same class – which Foundry’s design inherently avoids by linking subclass to class). The heavy logic (HP calculation, slots, ability mods, etc.) can be directly informed by Foundry 5e’s logic. Expect to spend effort rewriting, but you can do so with high confidence in the correctness of the result because the Foundry system has been extensively tested by its community (it’s the official 5e system, used by thousands of games). In other words, the Foundry dnd5e system can serve as a blueprint and a database for your project. You will extract the blueprint and reconstruct it in your own TypeScript architecture. This is a significant but very achievable project – certainly far less work than coding a 5e char builder from scratch without this resource.
Sources:
    • Foundry VTT D&D5E README and manifest, noting scope and licensing.
    • FoundryVTT dnd5e system manifest (system.json) showing item types and compendium packs for classes, races, features, etc..
    • Class Data Model (class.mjs) – schema for class items (hit dice, levels, spellcasting, etc.)[4].
    • Advancement Guide (GitHub Issue #1492) – describes the new advancement system and how class advancements grant features and choices.
    • Item5e linking logic – how classes and subclasses reference each other by identifier[29][26].
    • Actor5e spell slot computation – summing spellcasting progression from multiple classes[15][33].
    • Licensing notes in README – MIT license for code, CC-BY-4.0 for SRD content.

[1] [9] [10] [11] [12] [15] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [33] GitHub
https://github.com/foundryvtt/dnd5e/blob/b24332d12da26499b5357be75467a48371af09ad/module/documents/actor/actor.mjs
[2] [26] [27] [28] [29] GitHub
https://github.com/foundryvtt/dnd5e/blob/b24332d12da26499b5357be75467a48371af09ad/module/documents/item.mjs
[3] [4] [5] [30] [31] [32] GitHub
https://github.com/foundryvtt/dnd5e/blob/b24332d12da26499b5357be75467a48371af09ad/module/data/item/class.mjs
[6] Advancement User Guide · Issue #1492 · foundryvtt/dnd5e · GitHub
https://github.com/foundryvtt/dnd5e/issues/1492
[7] [8] [13] [14] GitHub
https://github.com/Sir-Lancaster/DarkNorth/blob/7f60bd4959505c55e8db1940c063f581a2adb4d5/module/data/item/fields/spellcasting-field.mjs